= Fibonacci Message Passing Project
:author: Laolu Adewoye
:email: laoluadewoye@gmail.com>
:description: Explains the project and summarizes the repository contents.
:keywords: project, fibonacci, docker, kubernetes, asciidoc, pods, containers, network, server, stage, image, deployment, readme, schema, podman, compose

== Versioning

=== Project Version
include::latest_program.adoc[]

=== Project Changelog
include::changelog.adoc[]

=== Project Components

Latest Image Version:
include::fibonacci_image/latest_image.adoc[]

Use Case One Version:
include::use_case_one/latest_program.adoc[]

Use Case Two Version:
include::use_case_two/latest_program.adoc[]

Use Case Three Version:
include::use_case_three/latest_program.adoc[]

Use Case Four Version:
include::use_case_four/latest_program.adoc[]

== Required Software for Project

. Docker (With Docker Compose)
. Podman
. Kubernetes (with NGINX Ingress, CNI Networking Plugin, and Container Runtime that supports user namespaces)
.. I personally use Minikube with the Hyper-V driver, CRI-O container runtime, and enabled addons
. Helm
. Python
.. Python Cryptography Library
.. Python Pyyaml Library

=== Note about Kubernetes Use Cases

Everything is perfect about this project except for the very end of use cases three and four with the requests GET call. If you look into the `Main.py` files for these use cases, you will see that in the request call, the `verify` parameter used to feed a CA certificate to validate the certificates for the ingress is set to `False`. This is because at some point in the verification process when it's on, the call errors out due to a self-signed certificate error.

I have spent a total a few hours looking into this issue. The tls.crt file I feed into the Kubernetes ingress is a certificate chain with the ingress certificate first and the CA certificate second. Now that certificate is self-signed, and I believe the issue is the inherent distrust systems have for self-signed certificates unless the certificate in question is placed in a certificate trust store.

What is weird is that it only happens when the external host tries to connect to the Kubernetes ingress and nowhere else. The Gunicorn servers passing fibonacci numbers between each other do not seem to care. The Docker Compose setup and Podman setup runs without this error. The Pods inside the Kubernetes custer do not raise an issue. I have not had to place certificates in trust stores until now apparently.

I have decided to let it be for now. It's a minor issue, and the minor part of a big project and the minor bit is emphasized by the fact that setting verify to false lets the entire thing run smoothly. While attempting to fix it may be fun, I fear it may involve changing my host PC unnecessarily or doing some fanangling that would get boring pretty quickly.

I'm just putting this here in case anyone decides to look into the code and sees that weird setting so they have context.

== Explanation of Project Idea

This test is a way for me to force myself to get more familiar with container technologies, including Docker, Podman, and Kubernetes. I needed an idea that would ensure that I would not be able to complete it unscathed, but not so hard that months would go by before I am able to finish the project.

What I decided on is a self-propelling message passing network, with the fibonacci sequence being the core theme of the project. It was a simple enough concept that coding it would be a breeze while ensuring that I would learn how I can network containers and pods together. I could even learn other stuff along the way, like moving from Markdown readmes to AsciiDoc readmes.

=== Project Architecture

The image below shows how the network will operate conceptually. No matter what implementation is done under the hood, this is the agnostic form of the project.

image::extra_materials/concept_architecture.png["The concept architecture of the project. The PNG image shows four rounded boxes arranged in a rectangle with the boxes serving as corners of the square and wide blue arrows serving as the sides of the rectangle. The wide blue arrows are pointing in a clockwise fashion. The upper left box is a light red and has the label 'Server Stage 1.' The upper right box is a light orange and has the label 'Server Stage 2.' The lower right box is a light green and has the label 'Server Stage ... .' The lower left box is a light blue and has the label 'Server Stage N.'"]

In this diagram, the fibonacci server network is a ring topology made up of multiple server stages. A server stage is a unique step within the server network, and can be made up of one or multiple servers. This allows a server stage to be defined as a physical machine, a virtual machine, a container, a pod, or a set multiple machines.

In short, the server stage doesn't care about the underlying hardware or software. All the server stage cares about is where to expect communication from and where to send communication to.

Servers in a server stage will receive and send pairs of fibonacci numbers. The first number in a pair is the second-to-last number in the building fibonacci sequence (so far) while the second number in a pair is the latest number in the building fibonacci sequence. These numbers will be used to calculate a new fibonacci number, and then the old last number will be paired with the calculated number. This new pair will then be sent to the next server stage in the network loop.

For more details about what specifically goes on in a server within a server stage, check out the link:fibonacci_image/README.adoc[README] file within the `fibonacci_image` folder.

== Use Cases in Project

Three use cases are provided by the project.

The first use case uses Docker to create a Docker Compose application that networks container services together. Each container will represent a server stage in the fibonacci network. These containers have their own networking capabilities and are (sort of) directly managed by runtimes deployed by container engines. To read more about this use case, check out the use case's link:use_case_one/README.adoc[README].

The second use case uses Podman to create standalone containers that are networked to communicate with each other. Each container will represent a server stage in the fibonacci network. These containers have their own networking capabilities and are directly managed by runtimes deployed by container engines. To read more about this use case, check out the use case's link:use_case_two/README.adoc[README].

The third use case uses Kubernetes to create a pod that contains multiple containers. Each container will represent a server stage in the fibonacci network. The containers will share a network namespace inside the pod, and container platforms capable of pod management will manage the pod's activities. To read more about this use case, check out the use case's link:use_case_three/README.adoc[README].

The fourth use case uses Kubernetes to create single-container pods that are networked to communicate with each other. The pod abstraction allows container orchestrators to create a fibonacci network where a server stage can be represented by an entire deployment of pods. Container orchestrators would handle how network traffic travels between deployments, but core architecture of the network will not deviate from the image above. To read more about this use case, check out the use case's link:use_case_four/README.adoc[README].

Each use case has its own project folder that goes into more detail about how each use case will manifest. Docker, Podman, and Kubernetes are the container platform software used for the tests.

== Project-wide files

There are two files that will be used across the entire project. The first is `setup_config.json`, which is a JSON file that holds the keys and values necessary to customize a use case. The second is `GenerateTLS.py`, which is a Python program that is used project-wide to generate the TLS keys and certificates necessary for encrypted communication. The third is `KubeUtils.py`, which is a Python program that is used project-wide to generate configurations for various Kubernetes objects.

`setup_config.json` contains dozens of keys that are accessed by the use cases. All keys are written in camelcase. The following section will explain the schema.

=== Setup Config Schema

. _dns_
.. **Definition** -> Top-level key that specifies information related to defining domain names.
.. **Schema** -> JSON Object that contains the following keys:
... _countryInitials_
.... **Definition** -> `dns` member key that specifies the country initials to use when creating certificates.
.... **Schema** -> JSON string. Must be a valid `ISO 3166-1 alpha-2` initial.
... _domain_
.... **Definition** -> `dns` member key that specifies the root domain name for all entities.
.... **Schema** -> JSON string. Must use a Kubernetes-compatible schema.
... _default_
.... **Definition** -> `dns` member key that specifies the default domain name for all entities.
.... **Schema** -> JSON string. Must use a Kubernetes-compatible schema.
... _defaultIP_
.... **Definition** -> `dns` member key that specifies the default domain IP address for all entities.
.... **Schema** -> JSON string. Must be a valid IPv4 address.
... _defaultListeningIP_
.... **Definition** -> `dns` member key that specifies the default listening IP address for all entities.
.... **Schema** -> JSON string. Must be a valid IPv4 address.
... _caName_
.... **Definition** -> `dns` member key that specifies what CA items should be prefixed with.
.... **Schema** -> JSON string. Must use a Kubernetes-compatible schema.
... _externalName_
.... **Definition** -> `dns` member key that specifies what external items should be prefixed with.
.... **Schema** -> JSON string. Must use a Kubernetes-compatible schema.
... _ingressName_
.... **Definition** -> `dns` member key that specifies what ingress items should be prefixed with.
.... **Schema** -> JSON string. Must use a Kubernetes-compatible schema.
... _startAPI_
.... **Definition** -> `dns` member key that specifies the location of the starting API.
.... **Schema** -> JSON string. Must start with a slash and use a Kubernetes-compatible URL path.
. _engine_
.. **Definition** -> Top-level key that specifies information related to the settings to use for created container objects.
.. **Schema** -> JSON Object that contains the following keys:
... _network_
.... **Definition** -> `engine` member key that specifies information related to the network settings to use for containers and pods.
.... **Schema** -> JSON Object that contains the following keys:
..... _name_
...... **Definition** -> `network` member key that specifies the name of the network or network namespace to create.
...... **Schema** -> JSON string. Must be a name using letters and hyphens.
..... _driver_
...... **Definition** -> `network` member key that specifies the network type to assign to the network or network namespace.
...... **Schema** -> JSON string. Must be a valid Docker/Podman driver type.
..... _subnet_
...... **Definition** -> `network` member key that specifies the IPv4 (with subnet mask) network subnet to assign to the network or network namespace.
...... **Schema** -> JSON string. Must be a valid IPv4 network address and subnet mask.
..... _range_
...... **Definition** -> `network` member key that specifies the IPv4 network range to assign to the network or network namespace.
...... **Schema** -> JSON string. Must be a valid IPv4 network address and subnet mask.
..... _gateway_
...... **Definition** -> `network` member key that specifies the IPv4 network gateway to assign to the network or network namespace.
...... **Schema** -> JSON string. Must be a valid IPv4 address.
..... _prefix_
...... **Definition** -> `network` member key that specifies the IPv4 network prefix to assign to containers and pods in the network or network namespace.
...... **Schema** -> JSON string. Must be a valid IPv4 network prefix.
..... _startAddress_
...... **Definition** -> `network` member key that specifies the IPv4 starting host address number to assign to containers and pods in the network or network namespace.
...... **Schema** -> JSON integer. Must be a valid integer that, when combined with `prefix`, does results in an unused IPv4 address.
... _startPort_
.... **Definition** -> `engine` member key that specifies the starting non-privileged port number to assign to containers and pods in the network or network namespace.
.... **Schema** -> JSON integer. Must be a valid port number that is not an IANA well known port.
... _healthcheckCMD_
.... **Definition** -> `engine` member key that specifies the command to run for a healthcheck.
.... **Schema** -> JSON string. Must be a valid UNIX command string.
... _containerRestartPolicy_
.... **Definition** -> `engine` member key that specifies the restart policy for containers.
.... **Schema** -> JSON string. Must be a valid Docker/Podman restart policy.
... _containerFailPolicy_
.... **Definition** -> `engine` member key that specifies the health check failure policy for containers.
.... **Schema** -> JSON string. Must be a valid Docker/Podman healthcheck fail policy.
. _envs_
.. **Definition** -> Top-level key that specifies information related to environmental variables that isn't covered by other JSON keys.
.. **Schema** -> JSON Object that contains the following keys:
... _selfName_
.... **Definition** -> `envs` member key that specifies what to call server TLS materials.
.... **Schema** -> JSON string.
... _tlsTarget_
.... **Definition** -> `envs` member key that specifies the expected absolute filepath for a server's TLS directory.
.... **Schema** -> JSON string. Must be a valid UNIX absolute filepath.
... _throttleInterval_
.... **Definition** -> `envs` member key that specifies the interval in seconds that a server should wait between receiving numbers and sending numbers.
.... **Schema** -> JSON integer.
... _upperBound_
.... **Definition** -> `envs` member key that specifies the number that, upon reaching, the server should stop sending new numbers.
.... **Schema** -> JSON integer
. _fs_
.. **Definition** -> Top-level key that specifies information related to filepath locations in the project directory, not the internal filesystem of a containerized server.
.. **Schema** -> JSON Object that contains the following keys:
... _tlsFolder_
.... **Definition** -> `fs` member key that specifies the folder in the project directory that stores TLS materials.
.... **Schema** -> JSON string. Must be a folder name with no pathing.
... _outputFolder_
.... **Definition** -> `fs` member key that specifies the folder in a use case directory that stores generated content.
.... **Schema** -> JSON string. Must be a folder name with no pathing.
... _certExt_
.... **Definition** -> `fs` member key that specifies the file extension to use for exported PEM certificates.
.... **Schema** -> JSON string
... _keyExt_
.... **Definition** -> `fs` member key that specifies the file extension to use for exported PEM keys.
.... **Schema** -> JSON string
... _imageVersionFp_
.... **Definition** -> `fs` member key that specifies the file that holds the fibonacci image version to use.
.... **Schema** -> JSON string
... _composeOutput_
.... **Definition** -> `fs` member key that specifies the file that holds the output for use case one.
.... **Schema** -> JSON string
. _orchestrator_
.. **Definition** -> Top-level key that specifies information related to the settings to use for created orchestrator objects.
.. **Schema** -> JSON Object that contains the following keys:
... _helm_
.... **Definition** -> `orchestrator` member key that specifies information related to the settings for helm to use during chart application.
.... **Schema** -> JSON Object that contains the following keys:
..... _allowedKubeVersion_
...... **Definition** -> `helm` member key that specifies the allowed kubernetes version for the helm chart.
...... **Schema** -> JSON string. Must use valid Helm chart syntax.
..... _apiVersion_
...... **Definition** -> `helm` member key that specifies the Helm API version to use.
...... **Schema** -> JSON string. Must be a valid Helm API version.
..... _chartType_
...... **Definition** -> `helm` member key that specifies the Helm Chart Type.
...... **Schema** -> JSON string. Must be a valid Helm chart type.
..... _home_
...... **Definition** -> `helm` member key that specifies the home URL for the chart being deployed.
...... **Schema** -> JSON string. Must be a valid HTTPS web address.
..... _hook_
...... **Definition** -> `helm` member key that specifies the type of hook to use for helm chart templates.
...... **Schema** -> JSON string. Must be set to 'pre-install' to help control template installation order.
..... _hookPolicy_
...... **Definition** -> `helm` member key that specifies the policy to use when deciding to delete hooks.
...... **Schema** -> JSON string. Must be set to 'hook-failed' to prevent deletion of early template installations.
..... _templateFolder_
...... **Definition** -> `helm` member key that specifies the location of templates in a chart directory.
...... **Schema** -> JSON string. Must be a valid folder name with no pathing.
... _namespacePolicy_
.... **Definition** -> `orchestrator` member key that specifies the security policy for namespaces.
.... **Schema** -> JSON string. Must be a valid orchestrator security policy level.
... _podRestartPolicy_
.... **Definition** -> `orchestrator` member key that specifies the restart policy for pods.
.... **Schema** -> JSON string. Must be a valid orchestrator pod restart policy.
... _replicas_
.... **Definition** -> `orchestrator` member key that specifies the number of replica pods to make for a given server stage.
.... **Schema** -> JSON integer.
. _server_
.. **Definition** -> Top-level key that specifies information related to the components the server implements for its functionality.
.. **Schema** -> JSON Object that contains the following keys:
... _api_
.... **Definition** -> `server` member key that specifies the web api that should be used.
.... **Schema** -> JSON string. Must be one of the following -> [rest, grpc, soap, graphql, mqtt]
... _datastore_
.... **Definition** -> `server` member key that specifies how data is stored.
.... **Schema** -> JSON string. Must be one of the following -> [none, file, elasticstack, mongodb, postgresql]
... _elasticstack_
.... **Definition** -> `server` member key that specifies settings for ElasticStack.
.... **Schema** -> JSON Object that contains the following keys:
... _mongodb_
.... **Definition** -> `server` member key that specifies settings for MongoDB.
.... **Schema** -> JSON Object that contains the following keys:
... _postgresql_
.... **Definition** -> `server` member key that specifies settings for PostgreSQL.
.... **Schema** -> JSON Object that contains the following keys:
. _stage_
.. **Definition** -> Top-level key that specifies information related to the settings specific to the abstract server stage.
.. **Schema** -> JSON Object that contains the following keys:
... _composeNameSuffix_
.... **Definition** -> `stage` member key that specifies the suffix for Docker Compose service names.
.... **Schema** -> JSON string. Must be a string of letters and dashes.
... _count_
.... **Definition** -> `stage` member key that specifies the amount of server stages to create.
.... **Schema** -> JSON integer.
... _namePrefix_
.... **Definition** -> `stage` member key that specifies the name prefix for servers, containers, and pods.
.... **Schema** -> JSON string. Must be a string of letters and dashes.
... _startDelay_
.... **Definition** -> `stage` member key that specifies how long in seconds should a program wait before calling a server's start API.
.... **Schema** -> JSON integer
... _useCasePrefix_
.... **Definition** -> `stage` member key that specifies the prefix to assign to a specific use case.
.... **Schema** -> JSON string. Must be a string of letters and dashes.
. _tls_
.. **Definition** -> Top-level key that specifies information related to attributes about TLS keys and certificates.
.. **Schema** -> JSON Object that contains the following keys:
... _cert_
.... **Definition** -> `tls` member key that specifies information related to TlS certificates.
.... **Schema** -> JSON Object that contains the following keys:
..... _validDaysCA_
...... **Definition** -> `cert` member key that specifies the valid duration of a CA certificate.
...... **Schema** -> JSON integer
..... _validDaysLeaf_
...... **Definition** -> `cert` member key that specifies the valid duration of a Leaf certificate.
...... **Schema** -> JSON integer
... _rsa_
.... **Definition** -> `tls` member key that specifies information related to RSA keys.
.... **Schema** -> JSON Object that contains the following keys:
..... _keyLength_
...... **Definition** -> `rsa` member key that specifies the amount of bits for an RSA key.
...... **Schema** -> JSON integer
..... _publicExponent_
...... **Definition** -> `rsa` member key that specifies the public exponent to use for RSA key generation.
...... **Schema** -> JSON integer
