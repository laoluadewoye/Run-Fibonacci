= Fibonacci Message Passing Project
:author: Laolu Adewoye
:email: laoluadewoye@gmail.com>
:description: Explains the project and summarizes the repository contents.
:keywords: project, fibonacci, docker, kubernetes, asciidoc, pods, containers, network, server, stage, image, deployment, readme, schema, podman, compose

== Versioning

Latest Image Version:
include::fibonacci_image/latest_image.adoc[]

Use Case One Version:
include::use_case_one/latest_program.adoc[]

Use Case Two Version:
include::use_case_two/latest_program.adoc[]

== Required Software for Project

. Docker (With Docker Compose)
. Podman
. Kubernetes (with NGINX Ingress and CNI Networking Plugin)
. Helm
. Python (3.13 is recommended)
.. Python Cryptography Library
.. Python Pyyaml Library

== Explanation of Project Idea

This test is a way for me to force myself to get more familiar with container technologies, including Docker, Podman, and Kubernetes. I needed an idea that would ensure that I would not be able to complete it unscathed, but not so hard that months would go by before I am able to finish the project.

What I decided on is a self-propelling message passing network, with the fibonacci sequence being the core theme of the project. It was a simple enough concept that coding it would be a breeze while ensuring that I would learn how I can network containers and pods together. I could even learn other stuff along the way, like moving from Markdown readmes to AsciiDoc readmes.

=== Project Architecture

The image below shows how the network will operate conceptually. No matter what implementation is done under the hood, this is the agnostic form of the project.

image::extra_materials/concept_architecture.png["The concept architecture of the project. The PNG image shows four rounded boxes arranged in a rectangle with the boxes serving as corners of the square and wide blue arrows serving as the sides of the rectangle. The wide blue arrows are pointing in a clockwise fashion. The upper left box is a light red and has the label 'Server Stage 1.' The upper right box is a light orange and has the label 'Server Stage 2.' The lower right box is a light green and has the label 'Server Stage ... .' The lower left box is a light blue and has the label 'Server Stage N.'"]

In this diagram, the fibonacci server network is a ring topology made up of multiple server stages. A server stage is a unique step within the server network, and can be made up of one or multiple servers. This allows a server stage to be defined as a physical machine, a virtual machine, a container, a pod, or a set multiple machines.

In short, the server stage doesn't care about the underlying hardware or software. All the server stage cares about is where to expect communication from and where to send communication to.

Servers in a server stage will receive and send pairs of fibonacci numbers. The first number in a pair is the second-to-last number in the building fibonacci sequence (so far) while the second number in a pair is the latest number in the building fibonacci sequence. These numbers will be used to calculate a new fibonacci number, and then the old last number will be paired with the calculated number. This new pair will then be sent to the next server stage in the network loop.

For more details about what specifically goes on in a server within a server stage, check out the link:fibonacci_image/README.adoc[README] file within the `fibonacci_image` folder.

== Use Cases in Project

Three use cases are provided by the project.

The first use case uses Docker to create a Docker Compose application that networks container services together. Each container will represent a server stage in the fibonacci network. These containers have their own networking capabilities and are (sort of) directly managed by runtimes deployed by container engines. To read more about this use case, check out the use case's link:use_case_one/README.adoc[README].

The second use case uses Podman to create standalone containers that are networked to communicate with each other. Each container will represent a server stage in the fibonacci network. These containers have their own networking capabilities and are directly managed by runtimes deployed by container engines. To read more about this use case, check out the use case's link:use_case_two/README.adoc[README].

The third use case uses Kubernetes to create a pod that contains multiple containers. Each container will represent a server stage in the fibonacci network. The containers will share a network namespace inside the pod, and container platforms capable of pod management will manage the pod's activities. To read more about this use case, check out the use case's link:use_case_three/README.adoc[README].

The fourth use case uses Kubernetes to create single-container pods that are networked to communicate with each other. The pod abstraction allows container orchestrators to create a fibonacci network where a server stage can be represented by an entire deployment of pods. Container orchestrators would handle how network traffic travels between deployments, but core architecture of the network will not deviate from the image above. To read more about this use case, check out the use case's link:use_case_four/README.adoc[README].

Each use case has its own project folder that goes into more detail about how each use case will manifest. Docker, Podman, and Kubernetes are the container platform software used for the tests.

== Project-wide files

There are two files that will be used across the entire project. The first is `setup_config.json`, which is a JSON file that holds the keys and values necessary to customize a use case. The second is `GenerateTLS.py`, which is a Python program that is used project-wide to generate the TLS keys and certificates necessary for encrypted communication.

`setup_config.json` contains dozens of keys that are accessed by the use cases. All keys are written in camelcase. The following section will explain the schema.

=== Setup Config Schema

. _dns_
.. **Definition** -> Top-level key that specifies information related to defining domain names.
.. **Schema** -> JSON Object that contains the following keys:
... _countryInitials_
.... **Definition** -> `dns` member key that specifies the country initials to use when creating certificates.
.... **Schema** -> JSON string
... _domain_
.... **Definition** -> `dns` member key that specifies the root domain name for all entities.
.... **Schema** -> JSON string
... _default_
.... **Definition** -> `dns` member key that specifies the default domain name for all entities.
.... **Schema** -> JSON string
... _defaultIP_
.... **Definition** -> `dns` member key that specifies the default domain IP address for all entities.
.... **Schema** -> JSON string
... _caName_
.... **Definition** -> `dns` member key that specifies what CA items should be prefixed with.
.... **Schema** -> JSON string
... _externalName_
.... **Definition** -> `dns` member key that specifies what external items should be prefixed with.
.... **Schema** -> JSON string
. _envs_
.. **Definition** -> Top-level key that specifies information related to environmental variables that isn't covered by other JSON keys.
.. **Schema** -> JSON Object that contains the following keys:
... _selfKeyTarget_
.... **Definition** -> `envs` member key that specifies the expected absolute filepath for a server's TLS key.
.... **Schema** -> JSON string
... _selfCertTarget_
.... **Definition** -> `envs` member key that specifies the expected absolute filepath for a server's TLS certificate.
.... **Schema** -> JSON string
... _caCertTarget_
.... **Definition** -> `envs` member key that specifies the expected absolute filepath for a server's TLS CA certificate.
.... **Schema** -> JSON string
... _throttleInterval_
.... **Definition** -> `envs` member key that specifies the interval in seconds that a server should wait between receiving numbers and sending numbers.
.... **Schema** -> JSON integer
... _upperBound_
.... **Definition** -> `envs` member key that specifies the number that, upon reaching, the server should stop sending new numbers.
.... **Schema** -> JSON integer
. _fs_
.. **Definition** -> Top-level key that specifies information related to filepath locations in the project directory, not the internal filesystem of a containerized server.
.. **Schema** -> JSON Object that contains the following keys:
... _tlsFolder_
.... **Definition** -> `fs` member key that specifies the folder in the project directory that stores TLS materials.
.... **Schema** -> JSON string
... _outputFolder_
.... **Definition** -> `fs` member key that specifies the folder in a use case directory that stores generated content.
.... **Schema** -> JSON string
... _certExt_
.... **Definition** -> `fs` member key that specifies the file extension to use for exported PEM certificates.
.... **Schema** -> JSON string
... _keyExt_
.... **Definition** -> `fs` member key that specifies the file extension to use for exported PEM keys.
.... **Schema** -> JSON string
... _imageVersionFp_
.... **Definition** -> `fs` member key that specifies the file that holds the fibonacci image version to use.
.... **Schema** -> JSON string
. _kube_
.. **Definition** -> Top-level key that specifies information related to the settings to use for created kubernetes objects.
.. **Schema** -> JSON Object that contains the following keys:
... _helm_
.... **Definition** -> `kube` member key that specifies information related to the settings for helm to use during chart application.
.... **Schema** -> JSON Object that contains the following keys:
..... _allowedKubeVersion_
...... **Definition** -> `helm` member key that specifies the allowed kubernetes version for the helm chart.
...... **Schema** -> JSON string
..... _apiVersion_
...... **Definition** -> `helm` member key that specifies the Helm API version to use.
...... **Schema** -> JSON string
..... _chartType_
...... **Definition** -> `helm` member key that specifies the Helm Chart Type.
...... **Schema** -> JSON string
..... _home_
...... **Definition** -> `helm` member key that specifies the home URL for the chart being deployed.
...... **Schema** -> JSON string
... _podRestartPolicy_
.... **Definition** -> `kube` member key that specifies the restart policy for pods.
.... **Schema** -> JSON string
. _platform_
.. **Definition** -> Top-level key that specifies information related to the settings to use for created container objects.
.. **Schema** -> JSON Object that contains the following keys:
... _network_
.... **Definition** -> `platform` member key that specifies information related to the network settings to use for containers and pods.
.... **Schema** -> JSON Object that contains the following keys:
..... _name_
...... **Definition** -> `network` member key that specifies the name of the network or network namespace to create.
...... **Schema** -> JSON string
..... _driver_
...... **Definition** -> `network` member key that specifies the network type to assign to the network or network namespace.
...... **Schema** -> JSON string
..... _subnet_
...... **Definition** -> `network` member key that specifies the IPv4 (with subnet mask) network subnet to assign to the network or network namespace.
...... **Schema** -> JSON string
..... _range_
...... **Definition** -> `network` member key that specifies the IPv4 network range to assign to the network or network namespace.
...... **Schema** -> JSON string
..... _gateway_
...... **Definition** -> `network` member key that specifies the IPv4 network gateway to assign to the network or network namespace.
...... **Schema** -> JSON string
..... _prefix_
...... **Definition** -> `network` member key that specifies the IPv4 network prefix to assign to containers and pods in the network or network namespace.
...... **Schema** -> JSON string
..... _startAddress_
...... **Definition** -> `network` member key that specifies the IPv4 starting host address number to assign to containers and pods in the network or network namespace.
...... **Schema** -> JSON integer
... _startPort_
.... **Definition** -> `platform` member key that specifies the starting non-privileged port number to assign to containers and pods in the network or network namespace.
.... **Schema** -> JSON integer
... _replicas_
.... **Definition** -> `platform` member key that specifies the number of replica containers and pods to make in a given server stage.
.... **Schema** -> JSON integer
... _healthcheckCMD_
.... **Definition** -> `platform` member key that specifies the command to run for a healthcheck.
.... **Schema** -> JSON string
... _containerRestartPolicy_
.... **Definition** -> `platform` member key that specifies the restart policy for containers.
.... **Schema** -> JSON string
... _containerFailPolicy_
.... **Definition** -> `platform` member key that specifies the health check failure policy for containers.
.... **Schema** -> JSON string
. _stage_
.. **Definition** -> Top-level key that specifies information related to the settings specific to the abstract server stage.
.. **Schema** -> JSON Object that contains the following keys:
... _composeNameSuffix_
.... **Definition** -> `stage` member key that specifies the suffix for Docker Compose service names.
.... **Schema** -> JSON string
... _count_
.... **Definition** -> `stage` member key that specifies the amount of server stages to create.
.... **Schema** -> JSON integer
... _namePrefix_
.... **Definition** -> `stage` member key that specifies the name prefix for servers, containers, and pods.
.... **Schema** -> JSON string
... _startDelay_
.... **Definition** -> `stage` member key that specifies how long in seconds should a program wait before calling a server's start API.
.... **Schema** -> JSON integer
... _useCasePrefix_
.... **Definition** -> `stage` member key that specifies the prefix to assign to a specific use case.
.... **Schema** -> JSON string
. _tls_
.. **Definition** -> Top-level key that specifies information related to attributes about TLS keys and certificates.
.. **Schema** -> JSON Object that contains the following keys:
... _cert_
.... **Definition** -> `tls` member key that specifies information related to TlS certificates.
.... **Schema** -> JSON Object that contains the following keys:
..... _validDaysCA_
...... **Definition** -> `cert` member key that specifies the valid duration of a CA certificate.
...... **Schema** -> JSON integer
..... _validDaysLeaf_
...... **Definition** -> `cert` member key that specifies the valid duration of a Leaf certificate.
...... **Schema** -> JSON integer
... _rsa_
.... **Definition** -> `tls` member key that specifies information related to RSA keys.
.... **Schema** -> JSON Object that contains the following keys:
..... _keyLength_
...... **Definition** -> `rsa` member key that specifies the amount of bits for an RSA key.
...... **Schema** -> JSON integer
..... _publicExponent_
...... **Definition** -> `rsa` member key that specifies the public exponent to use for RSA key generation.
...... **Schema** -> JSON integer
