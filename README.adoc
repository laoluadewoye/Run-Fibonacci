= Generic Fibonacci Image Specification
:author: Laolu Adewoye
:email: laoluadewoye@gmail.com>
:description: Explains the project and summarizes the repository contents.
:keywords:

== Explanation of Project Idea

This test is a way for me to force myself to get more familiar with container technologies, including Docker, Podman, and Kubernetes. I needed an idea that would ensure that I would not be able to complete it unscathed, but not so hard that months would go by before I am able to finish the project.

What I decided on is a self-propelling message passing network, with the fibonacci sequence being the core theme of the project. It was a simple enough concept that coding it would be a breeze while ensuring that I would learn how I can network containers and pods together. I could even learn other stuff along the way, like moving from Markdown readmes to AsciiDoc readmes.

=== Project Architecture

The image below shows how the network will operate conceptually. No matter what implementation is done under the hood, this is the agnostic form of the project.

image::extra_materials/concept_architecture.png["The concept architecture of the project. The PNG image shows four rounded boxes arranged in a rectangle with the boxes serving as corners of the square and wide blue arrows serving as the sides of the rectangle. The wide blue arrows are pointing in a clockwise fashion. The upper left box is a light red and has the label 'Server Stage 1.' The upper right box is a light orange and has the label 'Server Stage 2.' The lower right box is a light green and has the label 'Server Stage ... .' The lower left box is a light blue and has the label 'Server Stage N.'"]

In this diagram, the fibonacci server network is a ring topology made up of multiple server stages. A server stage is a unique step within the server network, and can be made up of one or multiple servers. This allows a server stage to be defined as a physical machine, a virtual machine, a container, a pod, or a set multiple machines.

In short, the server stage doesn't care about the underlying hardware or software. All the server stage cares about is where to expect communication from and where to send communication to.

Servers in a server stage will receive and send pairs of fibonacci numbers. The first number in a pair is the second-to-last number in the building fibonacci sequence (so far) while the second number in a pair is the latest number in the building fibonacci sequence. These numbers will be used to calculate a new fibonacci number, and then the old last number will be paired with the calculated number. This new pair will then be sent to the next server stage in the network loop.

For more details about what specifically goes on in a server within a server stage, check out the link:fibonacci_image/README.adoc[README] file within the `fibonacci_image` folder.

== Use Cases in Project

Three use cases are provided by the project.

The first use case is with standalone containers that are networked to communicate with each other. Each container will represent a server stage in the fibonacci network. These containers have their own networking capabilities and are directly managed by runtimes deployed by container engines such as Docker and Podman.

The second use case is a pod that contains multiple containers. Each container will represent a server stage in the fibonacci network. The containers will share a network namespace inside the pod, and container platforms capable of pod management such as Podman and Kubernetes will manage the pod's activities.

The third use case is with single-container pods that are networked to communicate with each other. The pod abstraction allows container orchestrators such as Kubernetes to create a fibonacci network where a server stage can be represented by an entire deployment of pods. Container orchestrators would handle how network traffic travels between deployments, but core architecture of the network will not deviate from the image above.

Each use case has its own project folder that goes into more detail about how each use case will manifest. Docker and Kubernetes are the container platform software used for the tests.
