= Generic Fibonacci Image Specification
:author: Laolu Adewoye
:email: laoluadewoye@gmail.com>
:description: Explains the project and summarizes the repository contents.
:keywords: project, fibonacci, docker, kubernetes, asciidoc, pods, containers, network, server, stage, image, deployment, readme

== Explanation of Project Idea

This test is a way for me to force myself to get more familiar with container technologies, including Docker, Podman, and Kubernetes. I needed an idea that would ensure that I would not be able to complete it unscathed, but not so hard that months would go by before I am able to finish the project.

What I decided on is a self-propelling message passing network, with the fibonacci sequence being the core theme of the project. It was a simple enough concept that coding it would be a breeze while ensuring that I would learn how I can network containers and pods together. I could even learn other stuff along the way, like moving from Markdown readmes to AsciiDoc readmes.

=== Project Architecture

The image below shows how the network will operate conceptually. No matter what implementation is done under the hood, this is the agnostic form of the project.

image::extra_materials/concept_architecture.png["The concept architecture of the project. The PNG image shows four rounded boxes arranged in a rectangle with the boxes serving as corners of the square and wide blue arrows serving as the sides of the rectangle. The wide blue arrows are pointing in a clockwise fashion. The upper left box is a light red and has the label 'Server Stage 1.' The upper right box is a light orange and has the label 'Server Stage 2.' The lower right box is a light green and has the label 'Server Stage ... .' The lower left box is a light blue and has the label 'Server Stage N.'"]

In this diagram, the fibonacci server network is a ring topology made up of multiple server stages. A server stage is a unique step within the server network, and can be made up of one or multiple servers. This allows a server stage to be defined as a physical machine, a virtual machine, a container, a pod, or a set multiple machines.

In short, the server stage doesn't care about the underlying hardware or software. All the server stage cares about is where to expect communication from and where to send communication to.

Servers in a server stage will receive and send pairs of fibonacci numbers. The first number in a pair is the second-to-last number in the building fibonacci sequence (so far) while the second number in a pair is the latest number in the building fibonacci sequence. These numbers will be used to calculate a new fibonacci number, and then the old last number will be paired with the calculated number. This new pair will then be sent to the next server stage in the network loop.

For more details about what specifically goes on in a server within a server stage, check out the link:fibonacci_image/README.adoc[README] file within the `fibonacci_image` folder.

== Use Cases in Project

Three use cases are provided by the project.

The first use case uses Docker to create a Docker Compose application that networks container services together. Each container will represent a server stage in the fibonacci network. These containers have their own networking capabilities and are (sort of) directly managed by runtimes deployed by container engines. To read more about this use case, check out the use case's link:use_case_one/README.adoc[README].

The second use case uses Podman to create standalone containers that are networked to communicate with each other. Each container will represent a server stage in the fibonacci network. These containers have their own networking capabilities and are directly managed by runtimes deployed by container engines. To read more about this use case, check out the use case's link:use_case_two/README.adoc[README].

The third use case uses Kubernetes to create a pod that contains multiple containers. Each container will represent a server stage in the fibonacci network. The containers will share a network namespace inside the pod, and container platforms capable of pod management will manage the pod's activities. To read more about this use case, check out the use case's link:use_case_three/README.adoc[README].

The fourth use case uses Kubernetes to create single-container pods that are networked to communicate with each other. The pod abstraction allows container orchestrators to create a fibonacci network where a server stage can be represented by an entire deployment of pods. Container orchestrators would handle how network traffic travels between deployments, but core architecture of the network will not deviate from the image above. To read more about this use case, check out the use case's link:use_case_four/README.adoc[README].

Each use case has its own project folder that goes into more detail about how each use case will manifest. Docker, Podman, and Kubernetes are the container platform software used for the tests.
