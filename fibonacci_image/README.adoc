= Generic Fibonacci Image Specification
:author: Laolu Adewoye
:email: laoluadewoye@gmail.com>
:description: Specification on how fibonacci server can be designed and configured.
:keywords: container, image, docker, podman, engine, build, specification, spec, fibonacci, alpine, pod, kubernetes, orchestration, flask, gunicorn, shell, dockerfile, healthcheck, Schema, argument, environment, variable, python, server, stage, network, address, ipv4, port, tls, certificate, key, ca, authority, throttle, limit, interval, max, upper, destination, forward, forwarding, rest, api, curl, http, https, alma

== Versioning

Image Repository: https://hub.docker.com/r/laoluade/run-fibonacci

Latest Image Version:
include::latest_image.adoc[]

=== Changelog

include::changelog.adoc[]

== Required software

. Docker or Podman
. OpenSSL
. PowerShell or POSIX-compliant Shell
. Curl
. Python (version 3.12 or higher is recommended, code is written in 3.13)

== Explanation of Image

This container image is a generic image for running a small fibonacci number passing server. This image is made to work in a number of different contexts, such as running as a standalone container or as part of a larger kubernetes deployment.

The following diagram displays the components of the server at a high level.

image:../extra_materials/image_components.png["Diagram of the componets of the generic fibonacci server. The biggest components are colored in dark blue boxes. They are the Gunicorn server, the send number daemon, and the health check daemon. There is a dark purple component called the TLS Materials as well. The gunicorn server contains a light blue box labeled Flask API, which represents the software REST endpoints for the server. Inside the Flask API box are three green boxes named STDOUT Logger, Send Threader, and REST APIs respectively. Inside the REST API box are three orange boxes that represent the default, healthcheck, and start endpoints of the server. Five directional arrows connect boxes, with the direction indicating that the first box utilizes another box. The REST API is connected to the STDOUT Logger. The default API Endpoint is connected to the Send Threader. The Send Threader is connected to the Send Number Daemon. The Health Check Daemon is connected to the healthcheck API Endpoint. The TLS Materials is connected to the Gunicorn Server."]

In this diagram, we can see what components comprise the server image. The majority of the server is contained within the Flask API, which in turn is managed by the Gunicorn Server. TLS materials are given to the Gunicorn Server to enable encrypted communication. Two daemons (which are actually shells scripts) are connected to the Flask API through different functions and endpoints. Lastly, the STDOUT Logger is there to record any activity that takes place.

The container image exposes three REST API points. The first is the Default route (`/`) that is used to pass along fibonacci numbers. The second is the healthcheck route (`/healthcheck`) that is used to perform health checks on the server. The third is the start route (`/start`) that is used to start the fibonacci number passing chain.

All important information about the server is printed to `STDOUT` using the Python `print` command's `flush` argument.

=== Files Used in Image

The four files used in this image are `gunicorn.conf.py`, `rest.py`, `send_healthcheck.sh`, and `send_next_fib.sh`. These files are located in the `components` folder.

`gunicorn.conf.py` is the configuration file used by Gunicorn to tailor the server. This file specifies the Flask server to use, the network socket that the server listens on, and the TLS files necessary for encrypted communication among other things.

`rest.py` is a Flask definition file that is served by Gunicorn. This file specifies REST logic for the API endpoints and instantiates the constants that are used during the server's runtime.

`send_healthcheck.sh` is the shell script that is called by an external management process to check the server's health. It utilizes Curl to send an HTTPS message to the running server. It is represented by the Health Check Daemon box in the diagram above.

`send_next_fib.sh` is the shell script that is called by the healthcheck API to send a pair of fibonacci numbers to another server stage. It utilizes Curl to send an HTTPS message to the destination endpoint. It is represented by the Send Number Daemon box in the diagram above.

=== Other Image Details

Here is a list of hardcoded details in the Dockerfile for the image. Feel free to change any of these values on your own system.

. The image defines two platforms as options to run the server.
.. Alpine Linux is the default platform used to run the server due to its lightweight nature. The image defines `docker.io/library/alpine:3.22` as the base layer image.
.. Alma Linux is an additional platform used for cases where a RHEL variant is preferred. The image defines `docker.io/library/almalinux:10-minimal` as the base layer image.
. The image defines the non-root user `app` to run the server.
. The image defines server contents to be kept in the `/usr/src/app` directory. The user `app` is given ownership of this directory.
. The image defines a healthcheck to monitor the state of the server.
.. The healthcheck is given a grace period of `10` seconds in the beginning.
.. The healthcheck is set to run every `10` seconds.
.. The healthcheck times out after `5` seconds if not complete.
.. The healthcheck has a maximum of `3` attempts to succeed before the server is deemed unhealthy.
.. The healthcheck runs the `/usr/src/app/send_healthcheck.sh` script to check server health.
. The image defines the `gunicorn` command to be the entrypoint of the container built by the image.

== Other Files in Directory

`README.adoc` is the file you are reading right now that explains everything about the image.

`changelog.adoc` is the secondary AsciiDoc file used to hold changelog information about the image.

`latest_image.adoc` is an AsciiDoc file used to hold the fully qualified name of the latest image.

`alpine.Dockerfile` is the file that defines the Alpine image.

`alma.Dockerfile` is the file that defines the Alma image.

`CreateImages.py` is the Python file used to create and push images and tags in one go.

`testing/TestGenTLS.py` is a Python script used to create the TLS materials for the testing images.

`testing/TestVersion.py` is a Python script used to test settings and platforms of the fibonacci server.

Note: For the test scripts, you will be on your own for scaling down the test. All that's created is a container and some TLS credential stuff though, so it should be easy.

== Software Bill of Materials

. Docker Official Images
.. This image uses the Alpine 3.22 and Alma 10 Minimal base layers.
. Python
.. This image uses Python 3.12 by Default.
. Python Flask
.. This image uses Flask version 3.1.2 by Default.
. Python Gunicorn
.. This image uses Gunicorn version 23.0.0 by Default.
. Curl
.. This image uses Curl version 8.16.0-r1 by Default.

== Configurable Server Environmental Arguments

**Important: All environmental variables in this section are required for the server to work. They do not have defaults.**

. _SERVER_API_
.. **Definition** -> The type of Server Web API to use.
.. **Schema** -> Must be one of a set of constants defined for the `server.api` key in `setup_config.json`.
. _SERVER_DATASTORE_
.. **Definition** -> The type of Datastore to use.
.. **Schema** -> Must be one of a set of constants defined for the `server.datastore` key in `setup_config.json`.
. _SERVER_STAGE_COUNT_
.. **Definition** -> The number of server stages in the test network.
.. **Schema** -> Must be a number that can be turned into a Python integer.
. _SERVER_STAGE_INDEX_
.. **Definition** -> The server stage designator of the server in the test network.
.. **Schema** -> Must be a number that can be turned into a Python integer. Must be between 0 and SERVER_STAGE_COUNT or equal to SERVER_STAGE_COUNT.
. _SELF_LISTENING_ADDRESS_
.. **Definition** -> The network address the server binds to in the test network.
.. **Schema** -> Must be either a IPv4 address or a FQDN.
. _SELF_HEALTHCHECK_ADDRESS_
.. **Definition** -> The network address the server uses to call itself in the test network.
.. **Schema** -> Must be either a IPv4 address or a FQDN.
. _SELF_PORT_
.. **Definition** -> The network port of the server in the test network.
.. **Schema** -> Must be non-privileged port number.
. _SECRET_KEY_TARGET_
.. **Definition** -> The location of the personal TLS encryption key of the server in the test network.
.. **Schema** -> Must be a UNIX absolute filepath.
. _SECRET_CERT_TARGET_
.. **Definition** -> The location of the personal TLS certificate of the server in the test network.
.. **Schema** -> Must be a UNIX absolute filepath.
. _SECRET_CA_CERT_TARGET_
.. **Definition** -> The location of the certificate authority TLS certificate of the server in the test network.
.. **Schema** -> Must be a UNIX absolute filepath.
. _DEST_ADDRESS_
.. **Definition** -> The network address of the server stage that the server should contact in the test network.
.. **Schema** -> Must be either a IPv4 address or a FQDN.
. _DEST_PORT_
.. **Definition** -> The network port of the server stage that the server should contact in the test network.
.. **Schema** -> Must be non-privileged port number.
. _DATASTORE_ADDRESS_
.. **Definition** -> The network address of the datastore that the server should contact in the test network.
.. **Schema** -> Must be either a IPv4 address or a FQDN.
. _DATASTORE_PORT_
.. **Definition** -> The network port of the datastore that the server should contact in the test network.
.. **Schema** -> Must be non-privileged port number.
. _THROTTLE_INTERVAL_
.. **Definition** -> The interval that the server should wait in seconds between receiving fibonacci numbers and sending fibonacci numbers.
.. **Schema** -> Must be a number that can be turned into a Python integer.
. _UPPER_BOUND_
.. **Definition** -> The number that the server must stop sending new fibonacci numbers if the last number the server received is larger than.
.. **Schema** -> Must be a number that can be turned into a Python integer.
